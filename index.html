<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Big Data Quiz – Profi-Edition</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    html { box-sizing: border-box; }
    *, *:before, *:after { box-sizing: inherit; }
    body { font-family: Arial, sans-serif; margin: 0; padding: 0 0 60px 0; background: #f0f2f5; }
    h1 { font-size: 1.4rem; padding: 16px; margin: 0; background: #007bff; color: #fff; border-radius: 0 0 12px 12px; }
    #progress, #timer { margin: 16px 0 12px 0; font-weight: bold; text-align: center; }
    #results { margin-top: 30px; padding: 20px; background: #fff; border-radius: 10px; }
    #submitBtn, #restartBtn {
      padding: 10px 20px; font-size: 1rem; margin: 12px auto 0 auto;
      display: block; border: none; border-radius: 6px; cursor: pointer;
      background: #007bff; color: white; width: 95%; max-width: 400px;
    }
    .question {
      background: #fff; padding: 15px; border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.07);
      margin: 14px auto; max-width: 600px;
    }
    .question h3 { margin-top: 0; font-size: 1.06rem; }
    .answers label {
      display: flex; align-items: center;
      margin: 5px 0; padding: 10px 12px;
      border: 1px solid #ccc; border-radius: 6px; background: #fff;
      font-size: 1rem; transition: background 0.15s;
    }
    .answers input[type="radio"], .answers input[type="checkbox"] {
      margin-right: 10px; width: 20px; height: 20px;
    }
    .correct { background-color: #c8f7c5 !important; }
    .incorrect { background-color: #f8d7da !important; }
    .explanation { font-style: italic; color: #555; margin-top: 10px; font-size: .95rem;}
    @media (max-width: 700px) {
      .question { max-width: 98vw; padding: 11px; }
      #results { padding: 12px; }
      #submitBtn, #restartBtn { font-size: 1.07rem; }
    }
    @media (max-width: 480px) {
      h1 { font-size: 1.1rem; padding: 10px; }
      .question h3 { font-size: .98rem; }
      .answers label { font-size: .96rem; padding: 8px 7px;}
    }
  </style>
</head>
<body>
  <h1>Big Data Lernquiz – Profi-Edition</h1>
  <div id="progress"></div>
  <div id="timer"></div>
  <form id="quizForm"></form>
  <button id="submitBtn">Quiz auswerten</button>
  <div id="results"></div>
  <button id="restartBtn" style="display:none;">Quiz neustarten</button>
  <script>
    const originalQuestions = [
      {
        question: "Ein Unternehmen möchte täglich mehrere Terabytes an Sensordaten aus der Produktion speichern und später flexibel auswerten. Welcher Speicheransatz ist dafür am besten geeignet?",
        answers: [
          { text: "Data Lake", correct: true },
          { text: "Relationale Datenbank mit starrer Struktur", correct: false },
          { text: "CSV-Dateien auf Einzelrechnern", correct: false },
          { text: "Excel", correct: false }
        ],
        explanation: "Ein Data Lake kann Rohdaten beliebiger Formate aufnehmen und flexibel für spätere Analysen bereitstellen."
      },
      {
        question: "Wähle alle typischen Vorteile von Apache Kafka für Big Data Anwendungen aus. (Mehrfachauswahl)",
        type: "multiple",
        answers: [
          { text: "Hohe Skalierbarkeit", correct: true },
          { text: "Ereignisbasierte Kommunikation (Event Streaming)", correct: true },
          { text: "Entkopplung von Sender und Empfänger", correct: true },
          { text: "Fest eingebaute Datenanalyse", correct: false }
        ],
        explanation: "Kafka ist skalierbar, arbeitet event-basiert und entkoppelt Sender/Empfänger, bietet aber keine fertige Analyse."
      },
      {
        question: "Du betreibst eine Big Data Plattform mit vielen Services, die sich dynamisch finden und verbinden sollen. Welches System wird oft als zentraler Konfigurations- und Synchronisationsdienst genutzt?",
        answers: [
          { text: "Apache Zookeeper", correct: true },
          { text: "Apache Hive", correct: false },
          { text: "PostgreSQL", correct: false },
          { text: "Excel Makros", correct: false }
        ],
        explanation: "Zookeeper sorgt für verteilten Konsens, Service-Discovery und Konfigurationsmanagement in vielen Big Data Architekturen."
      },
      {
        question: "Was unterscheidet 'Lambda-Architektur' und 'Kappa-Architektur' im Big Data Umfeld?",
        answers: [
          { text: "Lambda kombiniert Batch und Stream, Kappa nutzt nur Stream-Processing", correct: true },
          { text: "Beide nutzen ausschließlich Batch-Verarbeitung", correct: false },
          { text: "Lambda ist nur für kleine Datenmengen geeignet", correct: false },
          { text: "Kappa benötigt zwingend Hadoop", correct: false }
        ],
        explanation: "Lambda-Architektur trennt Batch- und Streamlayer, während Kappa-Architektur alles als Stream verarbeitet."
      },
      {
        question: "Welche Aussage trifft auf das CAP-Theorem in verteilten Systemen zu?",
        answers: [
          { text: "Bei Partitionierung kann ein System nur entweder Konsistenz oder Verfügbarkeit garantieren", correct: true },
          { text: "Partitionierung spielt keine Rolle", correct: false },
          { text: "Alle drei Eigenschaften (CAP) sind immer erreichbar", correct: false },
          { text: "CAP gilt nur für relationale Datenbanken", correct: false }
        ],
        explanation: "Im Fehlerfall (Netzwerk-Partitionierung) muss ein System laut CAP zwischen Konsistenz und Verfügbarkeit wählen."
      },
      {
        question: "Welche Vorteile bringt die Partitionierung von Daten in verteilten Datenbanken? (Mehrfachauswahl)",
        type: "multiple",
        answers: [
          { text: "Bessere Skalierbarkeit", correct: true },
          { text: "Lastverteilung", correct: true },
          { text: "Schnelleres Backup", correct: true },
          { text: "Erhöhte Speicherfragmentierung als Ziel", correct: false }
        ],
        explanation: "Partitionierung steigert Skalierbarkeit, verteilt die Last und vereinfacht Backups."
      },
      {
        question: "Welcher Vorteil bietet Protobuf (Protocol Buffers) gegenüber JSON beim Datenaustausch im Big Data Kontext?",
        answers: [
          { text: "Effizientere binäre Serialisierung und kleinere Nachrichten", correct: true },
          { text: "Kann nur Textdaten übertragen", correct: false },
          { text: "Ist ein relationales Datenbankschema", correct: false },
          { text: "Wird von Browsern direkt gerendert", correct: false }
        ],
        explanation: "Protobuf erzeugt kompakte, binäre Daten und ist schneller/parsersparender als JSON."
      },
      {
        question: "Welches Konsistenzmodell garantiert, dass nach jedem Schreibvorgang alle Nutzer sofort denselben Wert sehen?",
        answers: [
          { text: "Strong Consistency", correct: true },
          { text: "Eventual Consistency", correct: false },
          { text: "Causal Consistency", correct: false },
          { text: "Keine Konsistenz", correct: false }
        ],
        explanation: "Strong Consistency bedeutet: Nach jedem Write liest jeder denselben neuen Wert."
      },
      {
        question: "Welche NoSQL-Datenbank speichert Daten als Dokumente im JSON-ähnlichen Format?",
        answers: [
          { text: "MongoDB", correct: true },
          { text: "Cassandra", correct: false },
          { text: "Neo4j", correct: false },
          { text: "MySQL", correct: false }
        ],
        explanation: "MongoDB ist eine dokumentenorientierte NoSQL-Datenbank und verwendet BSON (ähnlich JSON)."
      },
      {
        question: "Was beschreibt 'Schema-on-Read' am besten?",
        answers: [
          { text: "Das Datenmodell wird erst beim Auslesen auf die Rohdaten angewendet", correct: true },
          { text: "Das Schema ist beim Schreiben festgelegt", correct: false },
          { text: "Die Daten haben nie ein Schema", correct: false },
          { text: "Nur für Protobuf relevant", correct: false }
        ],
        explanation: "Bei Schema-on-Read (z. B. Data Lake, Hadoop) wird das Schema dynamisch zur Abfragezeit interpretiert."
      },
      {
        question: "Welcher Vorteil ist typisch für Hadoop/HDFS gegenüber herkömmlichen Dateisystemen?",
        answers: [
          { text: "Daten werden redundant und verteilt auf vielen Knoten gespeichert", correct: true },
          { text: "Alle Daten müssen auf einer Festplatte liegen", correct: false },
          { text: "Keine Unterstützung für parallele Verarbeitung", correct: false },
          { text: "HDFS kann keine großen Dateien speichern", correct: false }
        ],
        explanation: "HDFS teilt Daten auf, speichert sie redundant und ermöglicht parallele Verarbeitung großer Datenmengen."
      },
      {
        question: "Spark wird im Vergleich zu MapReduce oft bevorzugt, weil...",
        answers: [
          { text: "es Daten im Speicher (RAM) verarbeiten kann und schneller ist", correct: true },
          { text: "es keine Cluster benötigt", correct: false },
          { text: "es keine Programmierschnittstellen bietet", correct: false },
          { text: "es keine Streams verarbeiten kann", correct: false }
        ],
        explanation: "Spark kann Daten im RAM halten und so Verarbeitung massiv beschleunigen."
      },
      {
        question: "Welche Layer gibt es in der Lambda-Architektur typischerweise? (Mehrfachauswahl)",
        type: "multiple",
        answers: [
          { text: "Batch Layer", correct: true },
          { text: "Speed Layer", correct: true },
          { text: "Serving Layer", correct: true },
          { text: "Visualization Layer", correct: false }
        ],
        explanation: "Lambda besteht aus Batch, Speed (Streaming) und Serving Layer."
      },
      {
        question: "Was ist ein typisches Szenario für den Einsatz von Eventual Consistency?",
        answers: [
          { text: "Globale Shopping-Plattform, bei der Verfügbarkeit wichtiger als sofortige Konsistenz ist", correct: true },
          { text: "Banküberweisung in Echtzeit", correct: false },
          { text: "Medizinische Patientendaten", correct: false },
          { text: "Daten auf einem lokalen USB-Stick", correct: false }
        ],
        explanation: "Hohe Verfügbarkeit und geografische Verteilung erfordern oft Eventual Consistency, z. B. bei E-Commerce."
      },
      {
        question: "Welche Rolle spielt Zookeeper in einem verteilten Kafka-Cluster?",
        answers: [
          { text: "Koordination, Leader Election und Metadatenhaltung", correct: true },
          { text: "Speichert die eigentlichen Nachrichten", correct: false },
          { text: "Visualisiert Nachrichtenströme", correct: false },
          { text: "Wird für SQL-Abfragen verwendet", correct: false }
        ],
        explanation: "Kafka nutzt Zookeeper u.a. zur Koordination und zum Failover."
      },
      {
        question: "Ein Unternehmen möchte sensitive Kundendaten DSGVO-konform in der Cloud analysieren. Was ist Pflicht? (Mehrfachauswahl)",
        type: "multiple",
        answers: [
          { text: "Datenverschlüsselung im Speicher und während der Übertragung", correct: true },
          { text: "Zugriffs- und Rechteverwaltung", correct: true },
          { text: "Dokumentation der Verarbeitung (Data Lineage)", correct: true },
          { text: "Daten können ohne jede Einschränkung weltweit verteilt werden", correct: false }
        ],
        explanation: "DSGVO fordert Schutzmaßnahmen, Kontrolle und Nachvollziehbarkeit."
      },
      {
        question: "In einem Streaming-Workflow (z.B. Kafka → Spark Streaming) sollen Werte kontinuierlich aggregiert werden. Welche Architektur wählst du?",
        answers: [
          { text: "Lambda- oder Kappa-Architektur mit Stream-Processing", correct: true },
          { text: "Nur klassisches Batch-Processing", correct: false },
          { text: "Pure OLTP-Architektur", correct: false },
          { text: "Nur Excel", correct: false }
        ],
        explanation: "Kontinuierliche Aggregation erfolgt meist via Stream-Processing (z.B. Kappa, Lambda-Architektur)."
      },
      {
        question: "Was ist bei der Implementierung von Data Governance wichtig? (Mehrfachauswahl)",
        type: "multiple",
        answers: [
          { text: "Klare Verantwortlichkeiten und Prozesse", correct: true },
          { text: "Metadaten-Management und Data Lineage", correct: true },
          { text: "Alle dürfen alles ändern", correct: false },
          { text: "Datenschutz wird ignoriert", correct: false }
        ],
        explanation: "Governance heißt: Verantwortung, Dokumentation, Kontrolle über Datenhaltung und -nutzung."
      },
      {
        question: "Du analysierst eine große Sammlung heterogener Logdaten. Was ist der Vorteil von 'Schema-on-Read' gegenüber 'Schema-on-Write'?",
        answers: [
          { text: "Flexibilität, da erst bei der Analyse ein Schema definiert werden muss", correct: true },
          { text: "Höhere Ladegeschwindigkeit bei jeder Datenquelle", correct: false },
          { text: "Alle Daten sind sofort konsistent", correct: false },
          { text: "Nur mit relationalen Datenbanken möglich", correct: false }
        ],
        explanation: "Unterschiedliche Formate können in Data Lakes gesammelt werden; die Struktur wird erst bei der Analyse benötigt."
      },
      {
        question: "Welches Problem löst das Publish-Subscribe-Pattern in komplexen Datenflüssen?",
        answers: [
          { text: "Entkoppelt Datenquelle und Empfänger, erleichtert Skalierung und Erweiterung", correct: true },
          { text: "Reduziert die Anzahl möglicher Datenquellen", correct: false },
          { text: "Macht synchrone Kommunikation notwendig", correct: false },
          { text: "Funktioniert nur mit SQL", correct: false }
        ],
        explanation: "Pub/Sub-Systeme wie Kafka erlauben lose Kopplung und flexible Verarbeitungspipelines."
      },
      {
        question: "Worin besteht ein Nachteil klassischer ETL-Prozesse gegenüber modernen ELT-Architekturen?",
        answers: [
          { text: "Transformationen vor dem Laden können zu langen Vorverarbeitungszeiten führen", correct: true },
          { text: "ETL bietet zu viel Flexibilität", correct: false },
          { text: "ETL arbeitet immer ohne Fehler", correct: false },
          { text: "ELT nutzt keine Zielplattformen", correct: false }
        ],
        explanation: "Bei ETL werden die Daten vor dem Laden transformiert, was Zeit und Ressourcen kosten kann."
      }
    ];

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    let shuffledQuestions = [];
    let timerInterval;
    let timeLeft;

    const quizForm = document.getElementById("quizForm");
    const results = document.getElementById("results");
    const progress = document.getElementById("progress");
    const timerDisplay = document.getElementById("timer");
    const submitBtn = document.getElementById("submitBtn");
    const restartBtn = document.getElementById("restartBtn");

    function startQuiz() {
      quizForm.innerHTML = "";
      results.innerHTML = "";
      submitBtn.disabled = false;
      restartBtn.style.display = "none";

      shuffledQuestions = shuffle(JSON.parse(JSON.stringify(originalQuestions)));
      timeLeft = shuffledQuestions.length * 60;
      updateTimer();

      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timeLeft--;
        updateTimer();
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          evaluateQuiz();
        }
      }, 1000);

      shuffledQuestions.forEach((q, index) => {
        const qAnswers = shuffle(q.answers.slice());
        const container = document.createElement("div");
        container.className = "question";

        const question = document.createElement("h3");
        question.innerText = `Frage ${index + 1}: ${q.question}`;
        container.appendChild(question);

        const answerContainer = document.createElement("div");
        answerContainer.className = "answers";

        qAnswers.forEach((a, i) => {
          const label = document.createElement("label");
          const input = document.createElement("input");
          input.type = q.type === 'multiple' ? 'checkbox' : 'radio';
          input.name = `q${index}`;
          input.dataset.correct = a.correct;
          input.dataset.index = i;
          label.appendChild(input);
          label.appendChild(document.createTextNode(a.text));
          answerContainer.appendChild(label);
        });

        container.appendChild(answerContainer);
        quizForm.appendChild(container);
      });

      updateProgress();
      quizForm.querySelectorAll("input").forEach(input => {
        input.onchange = updateProgress;
      });
    }

    function updateProgress() {
      const total = shuffledQuestions.length;
      const answered = Array.from(quizForm.querySelectorAll(".question")).filter(block => {
        const inputs = block.querySelectorAll("input");
        if (!inputs.length) return false;
        if (inputs[0].type === "radio") {
          return Array.from(inputs).some(i => i.checked);
        } else {
          return Array.from(inputs).some(i => i.checked);
        }
      }).length;
      progress.textContent = `Fortschritt: ${answered} von ${total} Fragen beantwortet`;
    }

    function updateTimer() {
      const minutes = Math.floor(timeLeft / 60);
      const seconds = timeLeft % 60;
      timerDisplay.textContent = `Verbleibende Zeit: ${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function evaluateQuiz() {
      let score = 0;
      const questionBlocks = quizForm.querySelectorAll(".question");

      questionBlocks.forEach((block, index) => {
        const inputs = block.querySelectorAll("input");
        const labels = block.querySelectorAll("label");
        const explanation = shuffledQuestions[index].explanation;
        let correct = true;

        inputs.forEach((input, i) => {
          input.disabled = true;
          const label = labels[i];
          const expected = input.dataset.correct === "true";
          const selected = input.checked;
          if (expected && selected) label.classList.add("correct");
          else if (!expected && selected) { label.classList.add("incorrect"); correct = false; }
          else if (expected && !selected) { label.classList.add("incorrect"); correct = false; }
        });

        // Für Multiple-Choice müssen exakt alle Richtigen gewählt werden, keine Falschen
        if (inputs[0].type === "checkbox") {
          const isAllCorrect = Array.from(inputs).every(input => 
            (input.dataset.correct === "true") === input.checked
          );
          if (isAllCorrect) score++;
        } else {
          if (correct) score++;
        }
        if (explanation) {
          const exp = document.createElement("div");
          exp.className = "explanation";
          exp.innerText = "Erklärung: " + explanation;
          block.appendChild(exp);
        }
      });

      results.innerHTML = `<h2>Dein Ergebnis:</h2><p>${score} von ${shuffledQuestions.length} Fragen korrekt beantwortet.</p>`;
      submitBtn.disabled = true;
      restartBtn.style.display = "inline-block";
    }

    submitBtn.onclick = function(e) {
      e.preventDefault();
      evaluateQuiz();
    };
    restartBtn.onclick = function(e) {
      e.preventDefault();
      startQuiz();
    };

    startQuiz();
  </script>
</body>
</html>
